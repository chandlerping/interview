# 设计模式
## 六大准则
1. 开放封闭：扩展，而非修改（稳定）
2. 里氏代换：子类在父类基础上扩展，可以代替基类（健壮）
3. 依赖倒转：面向接口编程，抽象
4. 接口隔离：解耦
5. 最少知道：对象之间尽量少知道，解耦
6. 单一职责：解耦

## 创建型模式
### 单例模式
一个类只有一个实例供全局访问。通常用于计数器，应用日志，线程池等。

优点：安全，受控，资源消耗低；缺点：不灵活，单点压力大。

创建方式：饿汉，懒汉，双重检验锁

### 简单工厂
单个工厂负责所有产品的创建。优点：结构简单；缺点：单个工厂职责过重，耦合度高

### 工厂方法
核心工厂下每个具体工厂子类负责某一具体产品的创建。优点：解耦；缺点：具体工厂繁杂

### 抽象工厂
核心工厂下每个工厂负责某一产品族的创建。

### 建造者模式
将复杂对象的构建和表示分离。场景：StringBuilder将单个char字符进行组合。

### 原型模式
复制已经存在的实例，避免加载和初始化等消耗，安全。使用场景：测试用User对象。

## 结构型模式
### 代理模式
通过代理控制对象访问，可在不改变原有流程和代码的情况下在对象调用方法 __之前、之后__ 添加新功能。

应用场景：异常处理，权限控制等

1. 静态代理：静态地对类进行代理，编译时已经确定。
2. JDK动态代理：使用JDK的反射机制（invoke）动态地在内存中加载代理class对象。创建效率高，执行效率低。
3. CGLIB动态代理：利用ASM（java字节码库）将代理类的class文件加载进内存并修改字节码生成子类，属于继承机制，创建效率低，执行效率高。

### 适配器模式
将一个类的接口转化成另一接口提高兼容性。

### 装饰器模式
动态的给一个对象添加额外功能。

### 外观模式
隐藏系统内部复杂性，给客户端提供访问系统的接口。

### 桥接模式
将抽象部分和实现部分分离，使其独立变化，灵活扩展。

### 组合模式
以树状结构表示不同层次的对象，便于分类管理一致性。

### 享元模式
运用共享技术支持大量细粒度对象，减少创建对象数量，避免内存溢出。（hash map）

## 行为型模式
### 模板方法
父类定义算法骨架模板，子类具体实现。

### 策略模式
定义一系列算法并封装，使其可以相互替换。

### 观察者模式
对象间一对多依赖，被观察这发生改变时通知依赖于它的对象，zookeeper。

### 备忘录模式
记录保存对象状态。

### 迭代模式
顺序访问聚合对象，无需暴露其内部。

### 责任链模式
避免请求发送者和接受者耦合，沿责任链传递请求处理。

### 命令模式
将请求封装成对象进行发送，使调用者和实现着解耦。

### 访问者模式

### 中介者模式
处理不同类之间的通信。

### 解释器模式
对语言定义解释器，SQL等。

### 状态模式
类的行为基于状态改变。



