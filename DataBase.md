# 数据库

### 1-COMPACT行格式？
| 额外信息：变长字段长度列表；NULL值列表；头信息 | row id，tx id，row ptr（MVCC 指向上一版本的record | 真实数据 |

一行最大65535字节，溢出后放在溢出页。


### 3-MySQL 优化
### 3.1-字段优化
1. 控制长度，使用可变长字段varchar
2. 设立冗余字段，空间换时间
3. 使用INT替代DATE

### 3.2-如何优化索引？
1. 对常用字段建立索引，选择区分度大的字段
2. 前缀索引
3. 覆盖索引
4. 主键自增
5. 防止索引失效（or非索引列、联合索引非最左匹配、对索引列计算或函数、查询数据范围过大）

### 3.3-如何优化SQL语句？
__pre__: 开启慢查询日志```slow_query_log```
1. 拆分长SQl，减少子查询
2. 走索引，避免select *
3. 少用JOIN，如果用的话尽量走索引
4. 用EXIST（外表驱动），IN（内表驱动）替换OR，NOT EXIST可以走索引
5. LIMIT分页
6. 将操作下移至业务端减少MYySQL单点压力

### 3.4-架构优化
1. 读写分离，主从复制，负载均衡
2. 使用缓存

### 3.5-分库分表？
* 为什么要分库？
  * 磁盘存储：业务量剧增，拆分数据库，减少平均磁盘IO
  * 高并发：高并发下大量请求，减少每个库的连接数，分担读写压力
* 为什么要分表？
  * 单表数据量过大（千万级）遇到存储和查询性能瓶颈
* 各种分库分表
  * 水平分库：以行为依据，按照一定策略（hash、range）将一个表的数据拆分到多个库
  * 垂直分库：以表为依据（业务属性）将不同表拆分到不同库
  * 水平分表：以行为依据将一个表按一定策略拆分成不同表
  * 垂直分表：以字段为依据（活跃性）将一个表拆分成多个表，将不常用或者过大的字段移出
* 如何选择分表键？
  * 用来分库、分表的字段，根据业务主题，比如用户ID，时间，地区等
* 非分表键如何查询？
  * 遍历（效率低）
  * 将数据冗余同步到ES，通过ES查询
* 分表策略
  * range：按范围划分，简单，但可能会有热点问题
  * hash：取hash值再取余，不会热点，但难以扩容
  * 一致性哈希：在hash基础上易扩容
* 如何避免热点数据？
  * range + hash
* 如何确保分布式事务？
  * 两阶段提交 所有参与者prepare + commit，由事务管理器统筹，简单但并发度低
  * SAGA：将长事务拆分成本地短事务 + 补偿机制，并发度高，一致性弱
  * 本地消息表：将操作放在一个事务里发送消息队列并消费，需轮询+消息队列
  * 最大努力通知：发起通知方最大努力将处理结果告知接收方（重复通知，接收方也需调用发起方接口查询结果）
* 跨节点join
  * 字段冗余：把需关联字段放入主表，空间换时间
  * 全局表：基础表在每个数据库中均保存一份
  * 数据抽象同步、应用层处理
* order by group by
  * 在每个节点上得到结果后再应用层合并
* 分布式ID
  * snowflake算法 时间戳41位 + 计算机id 10位 + 每台机器上生成ID的序列号（同一ms内创建）
* 需要停服吗？
   * 不用，编写代理层，在完成前先访问旧表数据
  
